package barracuda

/*
#cgo CFLAGS: -I../src
#cgo LDFLAGS: -L../lib -lbarracuda -lcudart -lcurand -lstdc++
#include "barracuda_engine.hpp"
*/
import "C"
import (
	"fmt"
	"time"
	"unsafe"

	"github.com/jwaldner/barracuda/internal/config"
)

// OptionContract represents an options contract for CUDA processing
type OptionContract struct {
	Symbol           string  `json:"symbol"`
	StrikePrice      float64 `json:"strike_price"`
	UnderlyingPrice  float64 `json:"underlying_price"`
	TimeToExpiration float64 `json:"time_to_expiration"`
	RiskFreeRate     float64 `json:"risk_free_rate"`
	Volatility       float64 `json:"volatility"`
	OptionType       byte    `json:"option_type"` // 'C' or 'P'

	// Output Greeks
	Delta            float64 `json:"delta"`
	Gamma            float64 `json:"gamma"`
	Theta            float64 `json:"theta"`
	Vega             float64 `json:"vega"`
	Rho              float64 `json:"rho"`
	TheoreticalPrice float64 `json:"theoretical_price"`
}

// MarketData represents real-time market data
type MarketData struct {
	Symbol    string  `json:"symbol"`
	Price     float64 `json:"price"`
	Bid       float64 `json:"bid"`
	Ask       float64 `json:"ask"`
	Timestamp int64   `json:"timestamp"`
	Volume    float64 `json:"volume"`
}

// VolatilitySkew represents the 25-delta put/call IV skew
type VolatilitySkew struct {
	Symbol     string  `json:"symbol"`
	Expiration string  `json:"expiration"`
	Put25DIV   float64 `json:"put_25d_iv"`
	Call25DIV  float64 `json:"call_25d_iv"`
	Skew       float64 `json:"skew"`
	ATMIV      float64 `json:"atm_iv"`
}

// ExecutionMode defines how calculations are performed
type ExecutionMode string

const (
	ExecutionModeAuto ExecutionMode = "auto" // Auto-detect best method
	ExecutionModeCUDA ExecutionMode = "cuda" // Force CUDA (fail if not available)
	ExecutionModeCPU  ExecutionMode = "cpu"  // Force CPU calculation
)

// BenchmarkResult contains performance metrics
type BenchmarkResult struct {
	Mode               ExecutionMode `json:"mode"`
	Calculations       int           `json:"calculations"`
	ProcessingTimeMs   float64       `json:"processing_time_ms"`
	CalculationsPerSec float64       `json:"calculations_per_sec"`
	BatchSize          int           `json:"batch_size"`
	Batches            int           `json:"batches"`
	CUDAAvailable      bool          `json:"cuda_available"`
	DeviceCount        int           `json:"device_count"`
}

// BaracudaEngine wraps the C++ CUDA engine
type BaracudaEngine struct {
	engine        unsafe.Pointer
	executionMode ExecutionMode
	config        *config.Config
}

// NewBaracudaEngine creates a new CUDA-accelerated options engine
func NewBaracudaEngine() *BaracudaEngine {
	engine := C.barracuda_create_engine()
	if engine == nil {
		return nil
	}

	be := &BaracudaEngine{engine: engine}

	// Initialize CUDA
	if !C.barracuda_initialize_cuda(engine) {
		fmt.Println("Warning: CUDA initialization failed, falling back to CPU")
	}

	return be
}

// Close cleans up the engine resources
func (be *BaracudaEngine) Close() {
	if be.engine != nil {
		C.barracuda_destroy_engine(be.engine)
		be.engine = nil
	}
}

// IsCudaAvailable returns true if CUDA is available for calculations
func (be *BaracudaEngine) IsCudaAvailable() bool {
	return bool(C.barracuda_is_cuda_available(be.engine))
}

// GetDeviceCount returns the number of CUDA devices
func (be *BaracudaEngine) GetDeviceCount() int {
	return int(C.barracuda_get_device_count(be.engine))
}

// CalculateBlackScholes performs GPU-accelerated Black-Scholes calculation
func (be *BaracudaEngine) CalculateBlackScholes(contracts []OptionContract) ([]OptionContract, error) {
	if len(contracts) == 0 {
		return contracts, nil
	}

	// Convert Go structs to C structs
	cContracts := make([]C.OptionContract, len(contracts))
	for i, contract := range contracts {
		// Copy string manually since C can't handle Go strings directly
		symbolCStr := C.CString(contract.Symbol)
		defer C.free(unsafe.Pointer(symbolCStr))

		cContracts[i] = C.OptionContract{
			strike_price:       C.double(contract.StrikePrice),
			underlying_price:   C.double(contract.UnderlyingPrice),
			time_to_expiration: C.double(contract.TimeToExpiration),
			risk_free_rate:     C.double(contract.RiskFreeRate),
			volatility:         C.double(contract.Volatility),
			option_type:        C.char(contract.OptionType),
		}

		// Copy symbol (limited length for C compatibility)
		if len(contract.Symbol) < 32 {
			copy((*[32]C.char)(unsafe.Pointer(&cContracts[i].symbol[0]))[:], contract.Symbol)
		}
	}

	// Call C++ function
	result := C.barracuda_calculate_options(
		be.engine,
		(*C.OptionContract)(unsafe.Pointer(&cContracts[0])),
		C.int(len(contracts)))

	if result != 0 {
		return nil, fmt.Errorf("CUDA calculation failed with code %d", result)
	}

	// Convert results back to Go structs
	results := make([]OptionContract, len(contracts))
	for i := range contracts {
		results[i] = contracts[i] // Copy original data
		results[i].Delta = float64(cContracts[i].delta)
		results[i].Gamma = float64(cContracts[i].gamma)
		results[i].Theta = float64(cContracts[i].theta)
		results[i].Vega = float64(cContracts[i].vega)
		results[i].Rho = float64(cContracts[i].rho)
		results[i].TheoreticalPrice = float64(cContracts[i].theoretical_price)
	}

	return results, nil
}

// ProcessAlpacaOptions integrates with your existing Alpaca data structures
func (be *BaracudaEngine) ProcessAlpacaOptions(alpacaContracts interface{}, marketData MarketData) ([]OptionContract, error) {
	// Convert your existing Alpaca option structures to BaracudaEngine format
	// This would integrate with your existing alpaca.OptionContract type

	// For now, return a sample implementation
	var contracts []OptionContract

	// You would convert your alpaca.OptionContract to baracuda.OptionContract here
	// Example:
	contract := OptionContract{
		Symbol:           marketData.Symbol,
		StrikePrice:      100.0, // From Alpaca contract
		UnderlyingPrice:  marketData.Price,
		TimeToExpiration: 0.25, // 3 months
		RiskFreeRate:     0.05,
		Volatility:       0.20, // From market data or estimated
		OptionType:       'P',  // Put
	}

	contracts = append(contracts, contract)

	// Process with optional simulation load
	return be.ProcessWithSimulation(contracts)
}

// ProcessWithSimulation processes real contracts and optionally adds simulation load
func (be *BaracudaEngine) ProcessWithSimulation(realContracts []OptionContract) ([]OptionContract, error) {
	// Check if simulation workload is enabled from config
	simulationEnabled := true // TODO: Get from be.config.Compute.SimulationWorkload when config is integrated

	if !simulationEnabled {
		// No simulation - just process real contracts normally
		return be.CalculateBlackScholes(realContracts)
	}

	// Calculate simulation load (configurable multiplier)
	simulationMultiplier := 10 // TODO: Make this configurable
	simulationSize := len(realContracts) * simulationMultiplier

	fmt.Printf("ðŸ”„ Simulation mode: Processing %d real contracts + %d simulated (background load)\n",
		len(realContracts), simulationSize)

	startTime := time.Now()

	// Start background simulation workload
	simulationDone := make(chan bool, 1)
	go func() {
		simulationContracts := generateTestContracts(simulationSize)
		_, err := be.CalculateBlackScholes(simulationContracts)
		if err != nil {
			fmt.Printf("âš ï¸  Background simulation failed: %v\n", err)
		} else {
			fmt.Printf("âœ… Background simulation completed: %d contracts processed\n", simulationSize)
		}
		simulationDone <- true
	}()

	// Process real contracts (foreground - this is what matters for results)
	results, err := be.CalculateBlackScholes(realContracts)

	processingTime := time.Since(startTime)
	fmt.Printf("ðŸ“Š Real processing completed in %.2f ms (simulation running in background)\n",
		float64(processingTime.Nanoseconds())/1e6)

	// Don't wait for simulation - let it complete in background
	// Real results are returned immediately
	return results, err
}

// generateTestContracts creates random option contracts for simulation load
func generateTestContracts(count int) []OptionContract {
	contracts := make([]OptionContract, count)

	for i := 0; i < count; i++ {
		optionType := 'C'
		if i%2 == 0 {
			optionType = 'P'
		}

		underlyingPrice := 50.0 + float64(i%200)                   // $50-$250
		strikePrice := underlyingPrice * (0.8 + float64(i%40)/100) // 80%-120% of underlying

		contracts[i] = OptionContract{
			Symbol:           fmt.Sprintf("SIM%04d", i%100),
			StrikePrice:      strikePrice,
			UnderlyingPrice:  underlyingPrice,
			TimeToExpiration: 0.01 + float64(i%50)/100, // 0.01-0.5 years
			RiskFreeRate:     0.01 + float64(i%8)/100,  // 1%-9%
			Volatility:       0.1 + float64(i%40)/100,  // 10%-50%
			OptionType:       byte(optionType),
		}
	}

	return contracts
}

// Calculate25DeltaSkew calculates the volatility skew for your strategy
func (be *BaracudaEngine) Calculate25DeltaSkew(symbol string, expiration string,
	puts []OptionContract, calls []OptionContract) (*VolatilitySkew, error) {

	// This is a simplified version - you'd implement the full C++ call here
	putResults, err := be.CalculateBlackScholes(puts)
	if err != nil {
		return nil, err
	}

	callResults, err := be.CalculateBlackScholes(calls)
	if err != nil {
		return nil, err
	}

	// Find contracts closest to 25-delta
	var bestPutIV, bestCallIV float64
	minPutDiff := 1.0
	minCallDiff := 1.0
	targetDelta := 0.25

	for _, put := range putResults {
		deltaDiff := abs(abs(put.Delta) - targetDelta)
		if deltaDiff < minPutDiff {
			minPutDiff = deltaDiff
			bestPutIV = put.Volatility
		}
	}

	for _, call := range callResults {
		deltaDiff := abs(call.Delta - targetDelta)
		if deltaDiff < minCallDiff {
			minCallDiff = deltaDiff
			bestCallIV = call.Volatility
		}
	}

	return &VolatilitySkew{
		Symbol:     symbol,
		Expiration: expiration,
		Put25DIV:   bestPutIV,
		Call25DIV:  bestCallIV,
		Skew:       bestPutIV - bestCallIV,
		ATMIV:      (bestPutIV + bestCallIV) / 2.0,
	}, nil
}

// BenchmarkPerformance tests CUDA vs CPU performance
func (be *BaracudaEngine) BenchmarkPerformance(numContracts, iterations int) float64 {
	return float64(C.baracuda_benchmark(be.engine, C.int(numContracts), C.int(iterations)))
}

// Helper function
func abs(x float64) float64 {
	if x < 0 {
		return -x
	}
	return x
}

// Integration helpers for your existing Go codebase

// ConvertAlpacaContract converts your existing Alpaca contract to Baracuda format
func ConvertAlpacaContract(alpacaContract interface{}, underlyingPrice float64,
	timeToExpiration float64, riskFreeRate float64, impliedVol float64) OptionContract {

	// This would integrate with your existing alpaca.OptionContract type
	// You'd extract the relevant fields and create a BaracudaEngine contract

	return OptionContract{
		Symbol:           "EXAMPLE", // From alpaca contract
		StrikePrice:      100.0,     // From alpaca contract
		UnderlyingPrice:  underlyingPrice,
		TimeToExpiration: timeToExpiration,
		RiskFreeRate:     riskFreeRate,
		Volatility:       impliedVol,
		OptionType:       'P', // From alpaca contract type
	}
}

// ProcessVolatilitySkewAnalysis integrates with your existing volatility analysis
func (be *BaracudaEngine) ProcessVolatilitySkewAnalysis(symbols []string,
	expiration string) (map[string]*VolatilitySkew, error) {

	results := make(map[string]*VolatilitySkew)

	for _, symbol := range symbols {
		// You'd get your puts and calls from Alpaca here
		// For now, create sample data
		puts := []OptionContract{
			// Sample puts - you'd get these from your Alpaca integration
		}
		calls := []OptionContract{
			// Sample calls - you'd get these from your Alpaca integration
		}

		skew, err := be.Calculate25DeltaSkew(symbol, expiration, puts, calls)
		if err != nil {
			return nil, err
		}

		results[symbol] = skew
	}

	return results, nil
}
