package handlers

import (
	"encoding/json"
	"fmt"
	"html/template"
	"log"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/jwaldner/barracuda/barracuda"
	"github.com/jwaldner/barracuda/internal/alpaca"
	"github.com/jwaldner/barracuda/internal/config"
	"github.com/jwaldner/barracuda/internal/models"
	"github.com/jwaldner/barracuda/internal/symbols"
)

// Handler manages all application routes and dependencies
type Handler struct {
	alpacaClient  *alpaca.Client
	engine        *barracuda.BaracudaEngine
	symbolService *symbols.SP500Service
	config        *config.Config
}

// NewHandler creates a new application handler with all dependencies
func NewHandler(alpacaClient *alpaca.Client, engine *barracuda.BaracudaEngine, cfg *config.Config) *Handler {
	return &Handler{
		alpacaClient:  alpacaClient,
		engine:        engine,
		symbolService: symbols.NewSP500Service("assets/symbols"),
		config:        cfg,
	}
}

// HomeHandler serves the main web interface
func (h *Handler) HomeHandler(w http.ResponseWriter, r *http.Request) {
	// Get S&P 500 symbols for the interface
	info, err := h.symbolService.GetSymbolsInfo()
	if err != nil {
		log.Printf("Warning: Could not get S&P 500 symbols: %v", err)
	}

	data := struct {
		Title           string
		DefaultStocks   []string
		DefaultCash     int
		DefaultStrategy string
		SP500Count      int
		CUDAAvailable   bool
		DeviceCount     int
		PaperTrading    bool
	}{
		Title:           "Barracuda Options Analyzer",
		DefaultStocks:   h.config.DefaultStocks,
		DefaultCash:     h.config.DefaultCash,
		DefaultStrategy: h.config.DefaultStrategy,
		SP500Count:      info.TotalSymbols,
		CUDAAvailable:   h.engine.IsCudaAvailable(),
		DeviceCount:     h.engine.GetDeviceCount(),
		PaperTrading:    h.config.AlpacaPaperTrading,
	}

	tmpl := `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{.Title}}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', system-ui, sans-serif; 
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white; 
            min-height: 100vh; 
            padding: 20px;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: rgba(255, 255, 255, 0.1); 
            backdrop-filter: blur(10px); 
            border-radius: 20px; 
            padding: 30px; 
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        .header { text-align: center; margin-bottom: 40px; }
        .header h1 { 
            font-size: 3em; 
            margin-bottom: 10px; 
            background: linear-gradient(45deg, #fff, #64b5f6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .status-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
            gap: 20px; 
            margin-bottom: 30px; 
        }
        .status-card { 
            background: rgba(255, 255, 255, 0.15); 
            padding: 20px; 
            border-radius: 15px; 
            text-align: center; 
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .status-card h3 { color: #64b5f6; margin-bottom: 10px; }
        .form-section { 
            background: rgba(255, 255, 255, 0.1); 
            padding: 30px; 
            border-radius: 15px; 
            margin-bottom: 30px; 
        }
        .form-row { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); 
            gap: 20px; 
            margin-bottom: 20px; 
        }
        .form-group { }
        .form-group label { 
            display: block; 
            margin-bottom: 8px; 
            font-weight: 600; 
            color: #e3f2fd; 
        }
        .form-group input, .form-group select, .form-group textarea { 
            width: 100%; 
            padding: 12px; 
            border: none; 
            border-radius: 8px; 
            background: rgba(255, 255, 255, 0.9); 
            color: #333; 
            font-size: 16px;
        }
        .form-group textarea { 
            min-height: 100px; 
            resize: vertical; 
        }
        .btn { 
            background: linear-gradient(45deg, #2196f3, #21cbf3); 
            color: white; 
            border: none; 
            padding: 15px 30px; 
            border-radius: 8px; 
            cursor: pointer; 
            font-size: 16px; 
            font-weight: 600; 
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .btn:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4); 
        }
        .results { 
            margin-top: 30px; 
            padding: 20px; 
            background: rgba(255, 255, 255, 0.1); 
            border-radius: 15px; 
            display: none; 
        }
        .loading { 
            text-align: center; 
            padding: 40px; 
            display: none; 
        }
        .spinner { 
            width: 40px; 
            height: 40px; 
            border: 4px solid rgba(255, 255, 255, 0.3); 
            border-top: 4px solid #2196f3; 
            border-radius: 50%; 
            animation: spin 1s linear infinite; 
            margin: 0 auto 20px; 
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .option-result { 
            background: rgba(255, 255, 255, 0.1); 
            padding: 20px; 
            margin: 10px 0; 
            border-radius: 10px; 
            border-left: 4px solid #2196f3; 
        }
        .result-header { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 10px; 
        }
        .symbol { 
            font-size: 1.5em; 
            font-weight: bold; 
            color: #64b5f6; 
        }
        .premium { 
            font-size: 1.3em; 
            font-weight: bold; 
            color: #4caf50; 
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ {{.Title}}</h1>
            <p>CUDA-Accelerated Options Analysis for S&P 500 Stocks</p>
        </div>

        <div class="status-grid">
            <div class="status-card">
                <h3>üöÄ CUDA Status</h3>
                <p>{{if .CUDAAvailable}}Enabled ({{.DeviceCount}} devices){{else}}CPU Fallback{{end}}</p>
            </div>
            <div class="status-card">
                <h3>üìä S&P 500 Symbols</h3>
                <p>{{.SP500Count}} Available</p>
            </div>
            <div class="status-card">
                <h3>üí∞ Trading Mode</h3>
                <p>{{if .PaperTrading}}Paper Trading{{else}}Live Trading{{end}}</p>
            </div>
            <div class="status-card">
                <h3>‚ö° Default Cash</h3>
                <p>${{.DefaultCash}}</p>
            </div>
        </div>

        <div class="form-section">
            <h2 style="margin-bottom: 20px;">üìà Options Analysis</h2>
            <form id="analysisForm">
                <div class="form-row">
                    <div class="form-group">
                        <label for="symbols">Stock Symbols (comma-separated)</label>
                        <textarea id="symbols" name="symbols" placeholder="AAPL, MSFT, GOOGL, AMZN, TSLA">{{range $i, $symbol := .DefaultStocks}}{{if $i}}, {{end}}{{$symbol}}{{end}}</textarea>
                    </div>
                    <div class="form-group">
                        <label for="strategy">Strategy</label>
                        <select id="strategy" name="strategy">
                            <option value="puts" {{if eq .DefaultStrategy "puts"}}selected{{end}}>Put Options</option>
                            <option value="calls" {{if eq .DefaultStrategy "calls"}}selected{{end}}>Call Options</option>
                        </select>
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="expiration">Expiration Date (YYYY-MM-DD)</label>
                        <input type="date" id="expiration" name="expiration" required>
                    </div>
                    <div class="form-group">
                        <label for="targetDelta">Target Delta</label>
                        <select id="targetDelta" name="targetDelta">
                            <option value="0.25">0.25 (Low Risk)</option>
                            <option value="0.50" selected>0.50 (Medium Risk)</option>
                            <option value="0.75">0.75 (High Risk)</option>
                        </select>
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="availableCash">Available Cash ($)</label>
                        <input type="number" id="availableCash" name="availableCash" value="{{.DefaultCash}}" min="1000" step="1000">
                    </div>
                    <div class="form-group" style="display: flex; align-items: end;">
                        <button type="submit" class="btn">üîç Analyze Options</button>
                    </div>
                </div>
            </form>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Analyzing options with CUDA acceleration...</p>
        </div>

        <div class="results" id="results">
            <h2>üìä Analysis Results</h2>
            <div id="resultsContent"></div>
        </div>
    </div>

    <script>
        // Set default expiration date to next Friday
        document.addEventListener('DOMContentLoaded', function() {
            const today = new Date();
            const dayOfWeek = today.getDay();
            const daysUntilFriday = (5 - dayOfWeek + 7) % 7 || 7;
            const nextFriday = new Date(today);
            nextFriday.setDate(today.getDate() + daysUntilFriday);
            
            document.getElementById('expiration').value = nextFriday.toISOString().split('T')[0];
        });

        document.getElementById('analysisForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const loadingDiv = document.getElementById('loading');
            const resultsDiv = document.getElementById('results');
            
            loadingDiv.style.display = 'block';
            resultsDiv.style.display = 'none';
            
            const formData = new FormData(e.target);
            const data = {
                symbols: formData.get('symbols').split(',').map(s => s.trim()),
                expiration_date: formData.get('expiration'),
                target_delta: parseFloat(formData.get('targetDelta')),
                available_cash: parseFloat(formData.get('availableCash')),
                strategy: formData.get('strategy')
            };
            
            try {
                const response = await fetch('/api/analyze', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(data)
                });
                
                const result = await response.json();
                
                if (!response.ok) {
                    throw new Error(result.error || 'Analysis failed');
                }
                
                displayResults(result);
            } catch (error) {
                alert('Error: ' + error.message);
            } finally {
                loadingDiv.style.display = 'none';
            }
        });
        
        function displayResults(data) {
            const resultsContent = document.getElementById('resultsContent');
            const resultsDiv = document.getElementById('results');
            
            if (!data.results || data.results.length === 0) {
                resultsContent.innerHTML = '<p>No suitable options found for the specified criteria.</p>';
                resultsDiv.style.display = 'block';
                return;
            }
            
            let html = '<p><strong>Analysis completed:</strong> ' + data.results.length + ' options analyzed</p>';
            
            data.results.forEach((option, index) => {
                const rank = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : 'üèÜ';
                
                html += '<div class="option-result">';
                html += '<div class="result-header">';
                html += '<span class="symbol">' + rank + ' ' + option.ticker + '</span>';
                html += '<span class="premium">$' + option.total_premium.toFixed(2) + '</span>';
                html += '</div>';
                html += '<p><strong>Strike:</strong> $' + option.strike.toFixed(2) + ' | ';
                html += '<strong>Stock Price:</strong> $' + option.stock_price.toFixed(2) + ' | ';
                html += '<strong>Contracts:</strong> ' + option.max_contracts + '</p>';
                html += '<p><strong>Premium per Contract:</strong> $' + option.premium.toFixed(2) + ' | ';
                html += '<strong>Delta:</strong> ' + (option.delta || 0).toFixed(3) + ' | ';
                html += '<strong>Days to Exp:</strong> ' + (option.days_to_expiration || 'N/A') + '</p>';
                html += '</div>';
            });
            
            resultsContent.innerHTML = html;
            resultsDiv.style.display = 'block';
        }
    </script>
</body>
</html>`

	t := template.Must(template.New("home").Parse(tmpl))
	if err := t.Execute(w, data); err != nil {
		http.Error(w, "Template error: "+err.Error(), http.StatusInternalServerError)
	}
}

// AnalyzeHandler handles options analysis requests
func (h *Handler) AnalyzeHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req models.AnalysisRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body: "+err.Error(), http.StatusBadRequest)
		return
	}

	// Validate request
	if len(req.Symbols) == 0 {
		http.Error(w, "At least one symbol is required", http.StatusBadRequest)
		return
	}
	if req.AvailableCash <= 0 {
		http.Error(w, "Available cash must be positive", http.StatusBadRequest)
		return
	}
	if req.Strategy != "puts" && req.Strategy != "calls" {
		http.Error(w, "Strategy must be 'puts' or 'calls'", http.StatusBadRequest)
		return
	}

	log.Printf("üìä Analyzing %s options for symbols: %v", req.Strategy, req.Symbols)

	// Get options data from Alpaca
	contractsBySymbol, err := h.alpacaClient.GetOptionsChain(req.Symbols, req.ExpirationDate, req.Strategy)
	if err != nil {
		log.Printf("‚ùå Error getting options chain: %v", err)
		http.Error(w, "Failed to get options data: "+err.Error(), http.StatusInternalServerError)
		return
	}

	var results []models.OptionResult

	// Process each symbol
	for _, symbol := range req.Symbols {
		symbol = strings.TrimSpace(symbol)
		contracts, exists := contractsBySymbol[symbol]
		if !exists || len(contracts) == 0 {
			log.Printf("‚ö†Ô∏è  No contracts found for %s", symbol)
			continue
		}

		// Get current stock price
		stockPrice, err := h.alpacaClient.GetStockPrice(symbol)
		if err != nil {
			log.Printf("‚ùå Error getting stock price for %s: %v", symbol, err)
			continue
		}

		// Find best contract using CUDA calculations
		result := h.findBestContract(contracts, stockPrice, req.TargetDelta, req.AvailableCash, req.Strategy)
		if result != nil {
			results = append(results, *result)
		}
	}

	// Sort results by total premium (highest first)
	for i := 0; i < len(results); i++ {
		for j := i + 1; j < len(results); j++ {
			if results[j].TotalPremium > results[i].TotalPremium {
				results[i], results[j] = results[j], results[i]
			}
		}
	}

	response := models.AnalysisResponse{
		Results:        results,
		RequestedDelta: req.TargetDelta,
		Strategy:       req.Strategy,
		ExpirationDate: req.ExpirationDate,
		Timestamp:      time.Now().Format(time.RFC3339),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// TestConnectionHandler tests Alpaca API connection
func (h *Handler) TestConnectionHandler(w http.ResponseWriter, r *http.Request) {
	if err := h.alpacaClient.TestConnection(); err != nil {
		response := map[string]interface{}{
			"status": "error",
			"message": "Alpaca API connection failed: " + err.Error(),
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusServiceUnavailable)
		json.NewEncoder(w).Encode(response)
		return
	}

	response := map[string]interface{}{
		"status":  "success",
		"message": "Alpaca API connection successful",
		"timestamp": time.Now().Format(time.RFC3339),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// findBestContract finds the best option contract using CUDA calculations
func (h *Handler) findBestContract(contracts []*alpaca.OptionContract, stockPrice *alpaca.StockPrice, targetDelta float64, availableCash float64, strategy string) *models.OptionResult {
	var bestResult *models.OptionResult
	bestDeltaDiff := 1.0

	for _, contract := range contracts {
		if !contract.Tradable {
			continue
		}

		// Parse strike price
		strikePrice, err := strconv.ParseFloat(contract.StrikePrice, 64)
		if err != nil {
			continue
		}

		// Calculate time to expiration
		expDate, err := time.Parse("2006-01-02", contract.ExpirationDate)
		if err != nil {
			continue
		}
		timeToExp := time.Until(expDate).Hours() / (24 * 365.25) // Years
		daysToExp := int(time.Until(expDate).Hours() / 24)

		if timeToExp <= 0 {
			continue // Skip expired options
		}

		// Create option contract for CUDA calculation
		optionContract := barracuda.OptionContract{
			Symbol:           contract.Symbol,
			StrikePrice:      strikePrice,
			UnderlyingPrice:  stockPrice.Price,
			TimeToExpiration: timeToExp,
			RiskFreeRate:     0.05, // 5% default risk-free rate
			Volatility:       0.25, // 25% default volatility
		}

		// Set option type
		if contract.Type == "call" {
			optionContract.OptionType = 'C'
		} else {
			optionContract.OptionType = 'P'
		}

		// Calculate using CUDA
		results, err := h.engine.CalculateBlackScholes([]barracuda.OptionContract{optionContract})
		if err != nil {
			log.Printf("CUDA calculation failed for %s: %v", stockPrice.Symbol, err)
			continue
		}

		if len(results) == 0 {
			continue
		}

		result := results[0]
		optionPrice := result.TheoreticalPrice
		delta := result.Delta

		// Check if this contract matches target delta better
		deltaDiff := abs(delta - targetDelta)
		if deltaDiff < bestDeltaDiff {
			// Calculate max contracts based on available cash
			premium := optionPrice * 100 // Options are priced per share but sold in contracts of 100
			maxContracts := int(availableCash / premium)
			
			if maxContracts > 0 {
				bestResult = &models.OptionResult{
					Ticker:       stockPrice.Symbol,
					OptionSymbol: contract.Symbol,
					OptionType:   contract.Type,
					Strike:       strikePrice,
					StockPrice:   stockPrice.Price,
					Premium:      premium,
					MaxContracts: maxContracts,
					TotalPremium: float64(maxContracts) * premium,
					Delta:        delta,
					Expiration:   contract.ExpirationDate,
					DaysToExp:    daysToExp,
				}
				bestDeltaDiff = deltaDiff
			}
		}
	}

	return bestResult
}

// calculateDelta calculates option delta using finite difference method
func (h *Handler) calculateDelta(S, K, T, r, vol float64, isCall bool) float64 {
	// Small change in stock price for finite difference
	dS := 0.01
	
	// Create option contracts for calculation
	optionType := byte('P')
	if isCall {
		optionType = byte('C')
	}
	
	contractUp := barracuda.OptionContract{
		Symbol:           "DELTA",
		StrikePrice:      K,
		UnderlyingPrice:  S + dS,
		TimeToExpiration: T,
		RiskFreeRate:     r,
		Volatility:       vol,
		OptionType:       optionType,
	}
	
	contractDown := barracuda.OptionContract{
		Symbol:           "DELTA",
		StrikePrice:      K,
		UnderlyingPrice:  S - dS,
		TimeToExpiration: T,
		RiskFreeRate:     r,
		Volatility:       vol,
		OptionType:       optionType,
	}
	
	// Calculate both prices
	resultsUp, err := h.engine.CalculateBlackScholes([]barracuda.OptionContract{contractUp})
	if err != nil {
		return 0.0
	}
	
	resultsDown, err := h.engine.CalculateBlackScholes([]barracuda.OptionContract{contractDown})
	if err != nil {
		return 0.0
	}
	
	if len(resultsUp) == 0 || len(resultsDown) == 0 {
		return 0.0
	}
	
	priceUp := resultsUp[0].TheoreticalPrice
	priceDown := resultsDown[0].TheoreticalPrice
	
	// Delta = (Price(S+dS) - Price(S-dS)) / (2*dS)
	return (priceUp - priceDown) / (2 * dS)
}

// abs returns the absolute value of a float64
func abs(x float64) float64 {
	if x < 0 {
		return -x
	}
	return x
}